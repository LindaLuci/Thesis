%\documentclass{book}
%\begin{document}
\chapter{Definizione del problema}
\setcounter{section}{1}
(replicazione dei dati - introduzione)
\item
\subsection{Cluster di database}
Un cluster \`{e} una raccolta di componenti che garantisce scalabit\`{a} e disponibilit\`{a} distribuendone i costi. Un cluster di database (SQL usa il termine cluster di catalogo) \`{e} una collezione di database gestiti da una singola istanza di un server database in esecuzione. Un'istanza \`{e} la raccolta di memoria e processi che interagiscono con un database, cio\`{e} l'insieme di file fisici che effettivamente memorizzano i dati.\cite{etichetta1} A tal fine, \`{e} possibile creare un cluster di database per applicazioni enterprise high-end, memorizzando e elaborando informazioni sui nodi.\\ L'architettura per un cluster di database \`{e} distinta da come le responsabilit\`{a} dei dati sono condivise tra i nodi di calcolo.

Seguono due dei vantaggi principarli offerti dal clustering, specialmente in un ambiente di database di alto volume:
\begin{itemize}
\item 
Fault tolerance (tolleranza di guasti): in caso di guasto del singolo server, il cluster offre un'alternativa, poich\'{e} esiste pi\`{u} di un server o istanza per gli utenti a cui connettersi.
\item
Load balancing (bilanciamento del carico): la funzionalit\`{a} di clustering \`{e} generalmente impostata per consentire agli utenti di essere assegnati automaticamente al server con il minor carico.\cite{etichetta1} 
\end{itemize}
Ci sono differenti tipi di architetture clustering, che si diversificano da come vengono memorizzati i dati e allocate le risorse.
La prima modalit\`{a} di clustering \`{e} conosciuta come architettura "Shared-Nothing" (SN). \`{E} un'architettura di elaborazione distribuita in cui ogni nodo/server \`{e} totalmente indipendente e autonomo, pertanto nessuno dei nodi condivide memoria o archiviazione del disco. Pi\`{u} generalmente, non esiste un unico punto di contesa nel sistema.\cite{etichetta5} Il partizionamento \`{e} tale che ogni nodo possiede un sottoinsieme dei dati, ovvero ogni nodo ha accesso esclusivo su quel particolare sottoinsieme. 
((Un esempio di questa forma di clustering potrebbe essere quando un'azienda ha pi\`{u} data centers per un unico sito web. Con molti server in tutto il mondo, nessun singolo server \`{e} un "master".\cite{etichetta2}))\\

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.70]{img/Shared_Nothing_Architecture.jpg}\\
\caption{Architecture Shared Nothing \label{figura1.1} \cite{etichetta7}}
\end{figure}

I vantaggi dell'architettura SN rispetto a un'entit\`{a} centrale che controlla la rete (un'architettura basata su controller) riguarda l'eliminazione di qualsiasi singolo punto di guasto, consentendo funzionalit\`{a} di (self-healing) auto-riparazione e fornendo un vantaggio nell'offrire aggiornamenti non distruttivi.\cite{etichetta6} 
\textbf{DA LEGGERE PER BENE ARTICOLO CITATO.}
Shared-nothing \`{e} anche noto come "database sharding". In generale, un sistema SN divide i suoi dati in vari nodi su database diversi o pu\`{o} richiedere a ciascun nodo di mantenere la propria copia dei dati dell'applicazione utilizzando un qualche tipo di protocollo di coordinamento.\cite{etichetta5}\\
Si oppone a quest'ultima, l'architettura nota come "shared-disk" (disco condiviso), in cui tutti i dati vengono memorizzati centralmente in un unico disco e sono accessibili da tutti i nodi di cluster.\cite{etichetta7} In questo tipo di struttura quindi pi\`{u} istanze di database vengono raggruppate in un singolo database sul disco. Nei sistemi di dischi condivisi, i blocchi (o pagine) di dati su disco possono avere un solo proprietario.((
La proprietà dei blocchi (o pagine) viene trasferita all'istanza che sta facendo l'aggiornamento. Questo genera traffico di rete e in genere un'infrastruttura dedicata viene implementata tra le istanze di database per far fronte a questo traffico.))
L'architettura Shared-Disk \`{e} un esempio di Synchronous Multi-Master, ovvero ogni istanza del database pu\`{o} scrivere (cio\`{e} \`{e} un master) in modo sincrono.\cite{etichetta7}
\textbf{DA CHIEDERE E DA CONTROLLARE ULTIME FRASI. GUARDA COMMENTO per il sito}
%https://en.wikibooks.org/wiki/Oracle_and_DB2,_Comparison_and_Compatibility/Database_Scaling/Shared_Architectures}}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.40]{img/Shared_Disk_Architecture.jpg}\\
\caption{Architecture Shared Disk - Shared Everything \label{figura1.2} \cite{etichetta7}}
\end{figure}

In un'architettura SD, grandi reti di computer possono operare su un singolo set di dati senza la necessit\`{a} di replicare o bloccare quel set di dati.\cite{etichetta7}
Shared Disk ha due vantaggi: ogni processore ha la propria memoria, il bus di memoria non \`{e} un collo di bottiglia (contrariamente all'architettura "Shared-Everything"). Inoltre il sistema offre un modo semplice per fornire un certo grado di tolleranza agli errori.\\

((La distinzione tra i due tipi \`{e} diventata confusa di recente con l'introduzione di grid computing o distribuzione cache. In questa configurazione, i dati sono ancora gestiti centralmente, ma controllati da un potente "server virtuale" composto da molti server che lavorano insieme come uno.\cite{etichetta2}))
\item
\subsection{Rete di pari}

\item
\subsection{Sistemi di ridondanza disco (RAID)}
RAID, acronimo di "Redundant Array of Independent Disks", insieme ridondante di dischi indipendenti (originariamente "Redundant Array of Inexpensive Disks"), \`{e} una tecnologia che permette di memorizzare dati su pi\`{u} dischi rigidi in un computer (o collegati ad esso) in modo da garantire una gestione sicura dei dati.\cite{etichetta9} I dispositivi RAID sono convenienti per sistemi che abbiano necessit\`{a} di grandi quantit\`{a} di dati continuamente disponibili. \textbf{History of RAID? non credo}

%Consente di ottenere quindi determinate caratteristiche di protezione e velocit\`{a} su sistemi "casalinghi" su dischi economici, in contrapposizione a configurazioni riservate per sistemi professionali ben pi\`{u} costosi.
%((Il RAID può essere implementata anche nei PC normali, sono infatti disponibili schede raid a basso costo quando non già presente sulle schede madri più sofisticate, ma è una tecnica tipicamente storicamente impiegata nei server o nelle workstation che richiedano grandi volumi o elevate prestazioni di immagazzinamento di dati, ad esempio per ospitare una base di dati)).\\ 

Il RAID, con modalit\`{a} differenti a seconda del tipo di configurazione, trae vantaggio dai principi di ridondanza dei dati e di parallelismo in modo da ottenere:
\begin{itemize}
\item 
incrementi di prestazioni (in lettura/scrittura)
\item
aumenti nella capacit\`{a} di memorizzazione disponibile
\item 
miglioramenti nella tolleranza ai guasti, ne segue migliore affidabilit\`{a}. \cite{etichetta10} Il RAID rende il sistema resiliente alla perdita di uno o pi\`{u} hard disk, permettendo di sostituirli senza l'interruzione del servizio.
\end{itemize}

I volumi RAID vengono percepiti dal sistema operativo come una singola unit\`{a}, indipendentemente dal numero di componenti che li costituiscono.

Il RAID funziona mettendo i dati su pi\`{u} dischi e consentendo operazioni di input/output (I/O) di sovrapporsi in modo equilibrato, migliorando le prestazioni. Poich\'{e} l'utilizzo di pi\`{u} dischi aumenta il tempo medio tra i guasti, memorizzare i dati ridondantemente aumenta anche la tolleranza agli errori.\\

I dati vengono suddivisi in "stripes", ovvero in sezioni di stessa  lunghezza, detta l'unit\`{a} del sezionamento e scritti su differenti dischi. Quando si richiede una lettura di dimensione superiore all'unit\`{a} di sezionamento, diverse implementazioni di diversi sistemi RAID distribuiscono l'operazione su pi\`{u} dischi in parallelo, aumentando le prestazioni. Ad esempio, se abbiamo sezioni da 1 bit e un array di D dischi, le sequenze di dati lunghe almeno D bit sfruttano tutti i dischi. \textbf{preso tutto da wikipedia}

\subsubsection{RAID hardware e software}
Il RAID pu\`{o} essere implementato sia con hardware dedicato che con software specifico.

Nel primo caso si tratta di unit\`{a} di controllo che gestiscono tutto autonomamente, facendo in modo che il sistema operativo veda in pratica un disco normale. 
Nel secondo caso, \`{e} il sistema operativo che associa i dischi e li gestisce usando una forma di ridondanza attraverso un normale controller (ATA, SCSI, Fibre Channel o altro).

Come si pu\`{o} comprendere, le unit\`{a} di controllo RAID sono pi\`{u} costose di quelle normali; tuttavia, se non si creano altri tipi di problemi, hanno il vantaggio di non creare difficolt\`{a} al sistema operativo.
\textbf{FARE CITAZIONE e controllare cosa c'e scritto su etichetta9 a riguardo}
\subsubsection{Controllore RAID}

\subsubsection{Livelli RAID}
La caratteristica fondamentale che identifica una configurazione RAID \`{e} l'array, che rappresenta il tipo di collegamento logico che c'\`{e} tra i vari dischi.
Con tale criterio viene determinato il livello RAID, ovvero la configurazione della tipologia di RAID  e stabilito il numero minimo di hard disk che sono necessari per attivarlo. A seconda del livello RAID sono implementate diverse caratteristiche operative per ottenere maggiori prestazioni o una maggiore sicurezza dei propri dati oppure entrambe le condizioni.\\
Si distinguono sei livelli, da 0 a 5.
Questo sistema numerato consente di differenziare le versioni e di scegliere come diffondere i dati attraverso l'array. Il numero di livelli \`{e} da allora ampliato ed \`{e} stato suddiviso in tre categorie: livelli RAID standard, nidificati e non standard.\cite{etichetta9}

\paragraph{Livelli RAID Standard}
\begin{itemize}
\item 
\textbf{RAID-O}: livello privo di ridondanza. Si occupa di unire due o pi\`{u} dischi, all'interno dei quali i dati vengono suddivisi equamente (tramite striping o sezionamento), in modo da bilanciare anche il carico di operazioni di lettura e scrittura che li riguardano. In pratica, il livello zero consente di realizzare un disco virtuale di grandi dimensioni, pi\`{u} efficiente, ma la rottura di uno dei dischi porta alla perdita di tutti i dati. RAID-0 \`{e} noto anche con il nome di "block striping".\\\textbf{bibliografia commentata}
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.40]{img/raid00.png}\\
\caption{Sezionamento senza ridondanza - Questa configurazione ha sezionamento, ma nessuna ridondanza dei dati. Offre le migliori prestazioni, ma nessuna tolleranza agli errori.\label{figura1.3}\cite{etichetta9}}
\end{figure}

\item 
\textbf{RAID-1}: livello che si occupa di unire assieme due o pi\`{u} dischi (generalmente solo due) che si trovano a riprodurre fedelmente tutti gli stessi dati. Questa configurazione mantiene quindi almeno una copia esatta di tutti i dati, detta "mirror". In questo caso, la rottura di un disco non pregiudica l'utilizzo dei dati che sono disponibili nel disco o nei dischi rimanenti.\\textbf{bibliografia commentata} Pi\`{u} precisamente, l'affidabilit\`{a} aumenta linearmente al numero di dischi presenti: un sistema con N dischi \`{e} in grado di resistere alla rottura di N-1 componenti.  RAID-1 \`{e} conosciuto anche come "disk mirroring".\\
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm

%DA WIKIPEDIA
%A livello prestazionale, il sistema RAID 1 aumenta tipicamente i risultati per le operazioni di lettura, perché molte implementazioni sono in grado di effettuare diverse operazioni in parallelo: mentre la lettura di un blocco è ancora in corso su un disco, cioè, possono effettuarne un'altra su un disco diverso. In ogni caso, la velocità di lettura raggiunge quella del disco più veloce in presenza di dispositivi di memorizzazione con prestazioni diverse: una singola operazione di lettura è richiesta inizialmente e contemporaneamente su tutti i dischi, ma si conclude nel momento della prima risposta ricevuta. Viceversa, la velocità di scrittura scende a quella del disco più lento, perché questo tipo di azione richiede il compimento della replica della stessa operazione su ogni disco dell'insieme.
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.40]{img/raid11.png}\\
\caption{Replicazione - Questa configurazione \`{e} costituita da almeno due unit\`{a} che duplicano la memorizzazione dei dati. Non c'\`{e} sezionamento. La lettura delle prestazioni \`{e} migliorata poich\'{e} entrambi i dischi possono essere letti contemporaneamente. La scrittura delle prestazioni \`{e} la stessa di quella per il singolo disco.\label{figura1.4} \cite{etichetta9}}
\end{figure}


\item
\textbf{RAID-2}:
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.40]{img/raid22.png}\\
\caption{Sezionamento a livello di bit - Questa configurazione utilizza la rigatura tra i dischi, con alcuni dischi che memorizzano le informazioni di errore di verifica e correzione (ECC).\label{figura1.6} \cite{etichetta9}}
\end{figure}

\item
\textbf{RAID-3}: livello che si occupa di unire assieme più dischi, all'interno dei quali i dati vengono suddivisi equamente, in modo da bilanciare anche il carico di operazioni di lettura e scrittura che li riguardano, dedicando uno di questi dischi al contenimento di un sistema di codici di controllo che permettono di ricostruire i dati nel caso uno degli altri dischi si rompa. In pratica, il livello tre crea una forma di ridondanza, ma meno affidabile del livello uno. Naturalmente, per attuare un livello tre servono almeno tre dischi.
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.40]{img/raid33.png}\\
\caption{Sezionamento a livello di byte con disco di parità - Questa tecnica utilizza la rigatura e dedica un'unità a memorizzare informazioni di parità. Le informazioni ECC incorporate vengono utilizzate per rilevare gli errori. Il recupero dei dati viene effettuato calcolando l'esclusiva OR (XOR) delle informazioni registrate sulle altre unità. Poiché un'operazione di I / O indirizza contemporaneamente tutte le unità, RAID 3 non può sovrapporre I / O. Per questo motivo, RAID 3 è la soluzione ideale per i sistemi a singolo utente con applicazioni di registrazione a lungo termine.\label{figura1.7} \cite{etichetta9}}
\end{figure}

\item
\textbf{RAID-4}: Il livello quattro dei sistemi RAID è simile al livello tre, con la differenza che vengono distribuiti in modo differente (più efficiente) tra i dischi, ma rimane compito di un disco separato il sistema di codici di controllo che permette la ricostruzione dei dati.
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.40]{img/raid44.png}\\
\caption{Sezionamento a livello di blocco con disco di parità\label{figura1.8} \cite{etichetta9}}
\end{figure}

\item
\textbf{RAID-5}: Il livello cinque dei sistemi RAID equivale al livello quattro, dove però le informazioni che servono per la ricostruzione dei dati sono distribuite tra i dischi, senza essere così concentrate in uno soltanto. In questo modo si aumenta l'efficienza, in termini di tempi di accesso ai dati.
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.40]{img/raid55.png}\\
\caption{Sezionamento a livello di blocco con parità distribuita\label{figura1.9} \cite{etichetta9}}
\end{figure}

\item
\textbf{RAID-6}: 
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm
\begin{figure}[htbp]
\centering
\includegraphics[scale=0.40]{img/raid66.png}\\
\caption{Sezionamento a livello di blocco con doppia parità distribuita\label{figura1.10} \cite{etichetta9}}
\end{figure}

\end{itemize}


\paragraph{Livelli RAID Nidificati Annidati}
I livelli Annidati sono dei tipi di livelli pi\`{u} complessi ottenuti dalla combinazione di alcuni livelli RAID Standard. Esempi classici sono le configurazioni RAID 0+1 o 10.

\paragraph{Livelli RAID Non-Standard}


%per proteggere i dati nel caso di un guasto di unit\`{a}.



\textbf{spiegazione cinci -audio-}
Nelle macchine non distribuite
per garantire la ridondanza dei dati si scrive su piu dischi, sincrono (i dati vengono scritti simultaneamente) - come raid mirroring
ci puo essere o un affarino (scheda) chiamato raid controller. Ha una memoria che puoi configurarlo.. puoi dirgli tra disco 1 e disco 2 imponi un raid 0. Quindi che succede? Da una macchina, cioe dal processore, tutte le volte che viene fatta una scrittura su disco, il raid controller la splitta e viene fatta in entrambi i dischi. quindi hai due dischi clonati (mirroring). Stessa cosa del REPLICA.
\item
\subsection{Codice di correzione errore (Erasure Coding)}
\textbf{http://searchstorage.techtarget.com/definition/erasure-coding}
\item
\section{Hardware utilizzato per gli esperimenti}
\textbf{Inserire foto hardware con descrizione}
\item
\section{Software utilizzato per gli esperimenti}
\item
\subsection{PosgreSQL}

\textbf{(spiegazione cinci -audio-)}
Uno dei punti di forza che ha reso famoso e versatile Posgres è che è un DBMS (Database Management System è un sistema software progettato per consentire la creazione e manipolazione efficiente di database (ovvero di collezioni di dati strutturati) ) (scritto in C). Ha dei rametti dove te riesci ad agganciarci dei software fatti ad OC. te ti agganci a un sistema di segnalistica interna e lui quindi tramite messaggi di scambio interno ti permette di lavorare (ti dice "ho fatto l'inserimento di questa tabella(INSERT), ti scatta il segnale, e te riesci a intercettare e quindi fare delle operazioni)

Pg Logical è un estensione di Posgres. Lui capisce quando fa inserimenti e riesce a duplicare soltando parti di database. Mentre replica di posgres per adesso ti replicherebbe tutto il DB. Invece noi si fa con solo tabelle (R) o quanti record di tabelle (per id maggiori di x) adirittura si vogliono replicare o colonne di tabelle \\


Con il termine PostgreSQL viene denominato un particolare ORDBMS, acronimo di Object-Relational DataBase Management System, cioè un software relazionale e ad oggetti per la gestione di basi di dati.
PostgreSQL è Open Source, quindi il suo codice sorgente è disponibile pubblicamente ed "aperto" ai contributi degli sviluppatori che volontariamente intendono partecipare alla sua implementazione.

In PostgreSQL, ma il discorso può essere allargato a tutti i gestori di database relazionali, i dati vengono rappresentati attraverso delle tabelle e le tabelle sono gestite utilizzando un linguaggio di alto livello chiamato SQL, acronimo di Structured Query Language.
Nel caso specifico, l'ORDBMS avrà il compito di gestire le operazioni di archiviazione e di salvaguardia dell'integrità dei dati allocati.

L'SQL è quindi un linguaggio a disposizione dell'utente da impiegare per "interfacciarsi" ai gestori di database; esso ha la caratteristica di agire in modo "trasparente", infatti le operazioni svolte a carico dei dati saranno portate avanti senza bisogno che l'utilizzatore sappia in che modo essi vengono trattati.\\
\textbf{(spiegazione cinci -audio-}\\
\textbf{(http://www.slony.info/images/Slony-I-concept.pdf}\\
Replicating schema changes is an often discussed problem and only ver y
fe w database systems provide the necessary hooks to implement it. PostgreSQL
does not provide the ability to define triggers called on schema changes, so a
transparent way to replicate schema changes is not possible without substantial
work in the core PostgreSQL system.
Moreover, ver y often database schema chages are not single, isolated DDL
statements that can occur at any time within a running system. Instead they tend
to be groups of DDL and DML statements that modify multiple database objects
and do mass data manipulation like updating a new column to its initial value.
The Slony-I replication system will have a mechanism to execute SQL
scr ipts in a controlled fashion as part of the replication process.

\item
\subsection{PG Logical}
L'estensione pglogical fornisce la replica logica di streaming per PostgreSQL, utilizzando un modulo di pubblicazione / sottoscrizione. Si basa sulla tecnologia sviluppata come parte del Progetto BDR.


PG Logical \`e un sistema logico di replica implementato come estensione di PostgreSQL. Completamente integrato, non richiede alcun triggers o programmi esterni. Questa alternativa alla replica fisica \`e un metodo altamente efficiente per replicare i dati utilizzando un modello di publish/subscribe per la replica selettiva.

I vantaggi offerti da Pg Logical sono i seguenti:
\begin{itemize}
\item
Replica sincrona
\item
Replica ritardata
\item
Risoluzione dei conflitti configurabili
\item
Capacit\`{a} di convertire lo standby fisico in una replica logica
\item
Pu\`{o} pubblicare i dati da PostgreSQL a un abbonato Postgres-XL
\item
Le sequenze possono essere replicate
\item
Nessun trigger significa ridurre il carico di scrittura sul Provider
\item
Nessuna re-esecuzione di SQL significa overhead e latenza ridotti per il Sottoscrittore
\item
Il sottoscrittore non \`{e} in ripristino di riposo caldo, in modo da poter utilizzare tavoli temp, non sbloccati o normali
\item
Non \`{e} necessario annullare le query per consentire alla replica di continuare la riproduzione
\item
Il sottoscrittore (Subscriber) pu\`{o} avere diversi utenti e protezione, indici diversi, impostazioni di parametri diversi
\item
Replica solo un database o un sottoinsieme di tabelle, noto come set di replica (Replication Sets)
\item
Replicare in versioni o architetture di PostgreSQL, consentendo aggiornamenti a bassa o zero-downtime
\item
Pi\`{u} server a monte in un singolo subscriber per l'accumulo di cambiamenti
\end{itemize}

Come funziona pglogical?
Pglogical utilizza le funzioni di Decodifica Logica aggiunte da 2ndQuadrant (e disponibili da PostgreSQL 9.4). Pglogical funziona ancora più veloce con PostgreSQL 9.5 e successive, con bassi overhead su entrambi i provider e abbonati.

Pglogical si basa molto sulle caratteristiche introdotte nell'ambito dello sviluppo BDR, tra cui:

Decodifica logica
Slot di replica
Lavoratori di sfondo statico
Origini di replica
Impegnano timestamp
Messaggi WAL logici
Replica pglogical Bi-Directional Replication (BDR)?
No. pglogical non fornisce funzionalità complete di replica multi-master e un supporto di modifica dello schema coerente, come fa la BDR. Pglogical incorpora le funzionalità di BDR e le lezioni apprese da BDR per produrre una soluzione più semplice e più semplice da utilizzare per la replica unidirezionale, utilizzabile da più persone per una vasta gamma di casi di utilizzo. BDR è stato progettato innanzitutto per il multi-master della rete a n-way, e questo è stato difficile adattarsi bene alla replica mono-master a senso unico.

Lo sviluppo di BDR continuerà per quelli che richiedono piena capacità multi-master, riutilizzando gran parte del codice da pglogical.


Casi di uso:
I diagrammi che seguono descrivono i gestori di database delle funzioni che sono in grado di eseguire con PgLogical.
\begin{figure}[htbp]
\centering
Migrare e aggiornare PostgreSQL con tempi di inattivit\`a quasi a zero
\includegraphics[scale=0.70]{img/pglogical_1.png}\\
\caption{Migrazione e aggiornamenti PostgreSQL \label{figura1} \cite{etichetta3}}
Accumulare le modifiche provenienti da server di database scartati in un data warehouse
\includegraphics[scale=0.70]{img/pglogical_2.png}\\
\caption{Aggregazione \label{figura2} 
\cite{etichetta4}}
\end{figure}
\begin{figure}[htbp]
\centering
Copiare tutti o una selezione di tabelle di database ad altri nodi di un cluster
\includegraphics[scale=0.70]{img/pglogical_3.png}\\
\caption{A cascata e distribuzione dati \label{figura3} \cite{etichetta4}}
Le modifiche del database in tempo reale ad altri sistemi
\includegraphics[scale=0.70]{img/pglogical_4.png}\\
\caption{A cascata e distribuzione dati \label{figura4} \cite{etichetta4}}
\end{figure}

\texttt{DA METTERE? DIFFERENZA TRA PG LOGICAL E BDR}
Replica pglogical Bi-Directional Replication (BDR)?
No. pglogical non fornisce funzionalità complete di replica multi-master e un supporto di modifica dello schema coerente, come fa la BDR. Pglogical incorpora le funzionalità di BDR e le lezioni apprese da BDR per produrre una soluzione più semplice e più semplice da utilizzare per la replica unidirezionale, utilizzabile da più persone per una vasta gamma di casi di utilizzo. BDR è stato progettato innanzitutto per il multi-master della rete a n-way, e questo è stato difficile adattarsi bene alla replica mono-master a senso unico.
%\end{document}
