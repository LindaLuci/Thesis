%\documentclass{book}
%\begin{document}
\chapter{Definizione del problema}
\setcounter{section}{1}
(replicazione dei dati - introduzione)
\item
\subsection{Cluster di database}
Un cluster \`{e} una raccolta di componenti che garantisce scalabit\`{a} e disponibilit\`{a} distribuendone i costi. Un cluster di database (SQL usa il termine cluster di catalogo) \`{e} una collezione di database gestiti da una singola istanza di un server database in esecuzione. Un'istanza \`{e} la raccolta di memoria e processi che interagiscono con un database, cio\`{e} l'insieme di file fisici che effettivamente memorizzano i dati.\cite{etichetta1} A tal fine, \`{e} possibile creare un cluster di database per applicazioni enterprise high-end, memorizzando e elaborando informazioni sui nodi.\\ L'architettura per un cluster di database \`{e} distinta da come le responsabilit\`{a} dei dati sono condivise tra i nodi di calcolo.

Seguono due dei vantaggi principarli offerti dal clustering, specialmente in un ambiente di database di alto volume:
\begin{itemize}
\item 
Fault tolerance (tolleranza di guasti): in caso di guasto del singolo server, il cluster offre un'alternativa, poich\'{e} esiste pi\`{u} di un server o istanza per gli utenti a cui connettersi.
\item
Load balancing (bilanciamento del carico): la funzionalit\`{a} di clustering \`{e} generalmente impostata per consentire agli utenti di essere assegnati automaticamente al server con il minor carico.\cite{etichetta1} 
\end{itemize}
Ci sono differenti tipi di architetture clustering, che si diversificano da come vengono memorizzati i dati e allocate le risorse.
La prima modalit\`{a} di clustering \`{e} conosciuta come architettura "Shared-Nothing" (SN). \`{E} un'architettura di elaborazione distribuita in cui ogni nodo/server \`{e} totalmente indipendente e autonomo, pertanto nessuno dei nodi condivide memoria o archiviazione del disco. Pi\`{u} generalmente, non esiste un unico punto di contesa nel sistema.\cite{etichetta5} Il partizionamento \`{e} tale che ogni nodo possiede un sottoinsieme dei dati, ovvero ogni nodo ha accesso esclusivo su quel particolare sottoinsieme. 
((Un esempio di questa forma di clustering potrebbe essere quando un'azienda ha pi\`{u} data centers per un unico sito web. Con molti server in tutto il mondo, nessun singolo server \`{e} un "master".\cite{etichetta2}))\\

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.70]{img/Shared_Nothing_Architecture.jpg}\\
\caption{Architecture Shared Nothing \label{figura1.1} \cite{etichetta7}}
\end{figure}

I vantaggi dell'architettura SN rispetto a un'entit\`{a} centrale che controlla la rete (un'architettura basata su controller) riguarda l'eliminazione di qualsiasi singolo punto di guasto, consentendo funzionalit\`{a} di (self-healing) auto-riparazione e fornendo un vantaggio nell'offrire aggiornamenti non distruttivi.\cite{etichetta6} 
\textbf{DA LEGGERE PER BENE ARTICOLO CITATO.}
Shared-nothing \`{e} anche noto come "database sharding". In generale, un sistema SN divide i suoi dati in vari nodi su database diversi o pu\`{o} richiedere a ciascun nodo di mantenere la propria copia dei dati dell'applicazione utilizzando un qualche tipo di protocollo di coordinamento.\cite{etichetta5}\\
Si oppone a quest'ultima, l'architettura nota come "shared-disk" (disco condiviso), in cui tutti i dati vengono memorizzati centralmente in un unico disco e sono accessibili da tutti i nodi di cluster.\cite{etichetta7} In questo tipo di struttura quindi pi\`{u} istanze di database vengono raggruppate in un singolo database sul disco. Nei sistemi di dischi condivisi, i blocchi (o pagine) di dati su disco possono avere un solo proprietario.((
La proprietà dei blocchi (o pagine) viene trasferita all'istanza che sta facendo l'aggiornamento. Questo genera traffico di rete e in genere un'infrastruttura dedicata viene implementata tra le istanze di database per far fronte a questo traffico.))
L'architettura Shared-Disk \`{e} un esempio di Synchronous Multi-Master, ovvero ogni istanza del database pu\`{o} scrivere (cio\`{e} \`{e} un master) in modo sincrono.\cite{etichetta7}
\textbf{DA CHIEDERE E DA CONTROLLARE ULTIME FRASI. GUARDA COMMENTO per il sito}
%https://en.wikibooks.org/wiki/Oracle_and_DB2,_Comparison_and_Compatibility/Database_Scaling/Shared_Architectures}}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.40]{img/Shared_Disk_Architecture.jpg}\\
\caption{Architecture Shared Disk - Shared Everything \label{figura1.2} \cite{etichetta7}}
\end{figure}

In un'architettura SD, grandi reti di computer possono operare su un singolo set di dati senza la necessit\`{a} di replicare o bloccare quel set di dati.\cite{etichetta7}
Shared Disk ha due vantaggi: ogni processore ha la propria memoria, il bus di memoria non \`{e} un collo di bottiglia (contrariamente all'architettura "Shared-Everything"). Inoltre il sistema offre un modo semplice per fornire un certo grado di tolleranza agli errori.\\

((La distinzione tra i due tipi \`{e} diventata confusa di recente con l'introduzione di grid computing o distribuzione cache. In questa configurazione, i dati sono ancora gestiti centralmente, ma controllati da un potente "server virtuale" composto da molti server che lavorano insieme come uno.\cite{etichetta2}))
\item
\subsection{Rete di pari}

\item
\subsection{Sistemi di ridondanza disco (RAID)}
RAID, acronimo di "Redundant Array of Independent Disks", insieme ridondante di dischi indipendenti (originariamente "Redundant Array of Inexpensive Disks"), \`{e} una tecnologia che permette di memorizzare dati su pi\`{u} dischi rigidi in un computer (o collegati ad esso) in modo da garantire una gestione sicura dei dati\cite{etichetta9}. I dispositivi RAID sono convenienti per sistemi che abbiano necessit\`{a} di grandi quantit\`{a} di dati continuamente disponibili. \textbf{History of RAID? non credo}

%Consente di ottenere quindi determinate caratteristiche di protezione e velocit\`{a} su sistemi "casalinghi" su dischi economici, in contrapposizione a configurazioni riservate per sistemi professionali ben pi\`{u} costosi.
%((Il RAID può essere implementata anche nei PC normali, sono infatti disponibili schede raid a basso costo quando non già presente sulle schede madri più sofisticate, ma è una tecnica tipicamente storicamente impiegata nei server o nelle workstation che richiedano grandi volumi o elevate prestazioni di immagazzinamento di dati, ad esempio per ospitare una base di dati)).\\ 

Il RAID, con modalit\`{a} differenti a seconda del tipo di configurazione, trae vantaggio dai principi di ridondanza dei dati e di parallelismo in modo da ottenere:
\begin{itemize}
\item 
incrementi di prestazioni (in lettura/scrittura)
\item
aumenti nella capacit\`{a} di memorizzazione disponibile
\item 
miglioramenti nella tolleranza ai guasti, ne segue migliore affidabilit\`{a}\cite{etichetta10}. Il RAID rende il sistema resiliente alla perdita di uno o pi\`{u} hard disk, permettendo di sostituirli senza l'interruzione del servizio.
\end{itemize}

I volumi RAID vengono percepiti dal sistema operativo come una singola unit\`{a}, indipendentemente dal numero di componenti che li costituiscono.

Il RAID funziona mettendo i dati su pi\`{u} dischi e consentendo operazioni di input/output (I/O) di sovrapporsi in modo equilibrato, migliorando le prestazioni. Poich\'{e} l'utilizzo di pi\`{u} dischi aumenta il tempo medio tra i guasti, memorizzare i dati ridondantemente aumenta anche la tolleranza agli errori.\\

I dati vengono suddivisi in "stripes", ovvero in sezioni di stessa  lunghezza, detta l'unit\`{a} del sezionamento e scritti su differenti dischi. Quando si richiede una lettura di dimensione superiore all'unit\`{a} di sezionamento, diverse implementazioni di diversi sistemi RAID distribuiscono l'operazione su pi\`{u} dischi in parallelo, aumentando le prestazioni. Ad esempio, se abbiamo sezioni da 1 bit e un array di D dischi, le sequenze di dati lunghe almeno D bit sfruttano tutti i dischi. \textbf{preso tutto da wikipedia}

\item
\subsubsection{RAID hardware e software}
Il RAID pu\`{o} essere implementato sia con hardware dedicato che con software specifico.

Nel primo caso si tratta di unit\`{a} di controllo che gestiscono tutto autonomamente, facendo in modo che il sistema operativo veda in pratica un disco normale. 
Nel secondo caso, \`{e} il sistema operativo che associa i dischi e li gestisce usando una forma di ridondanza attraverso un normale controller (ATA, SCSI, Fibre Channel o altro).

Come si pu\`{o} comprendere, le unit\`{a} di controllo RAID sono pi\`{u} costose di quelle normali; tuttavia, se non si creano altri tipi di problemi, hanno il vantaggio di non creare difficolt\`{a} al sistema operativo.
\textbf{FARE CITAZIONE e controllare cosa c'e scritto su etichetta9 a riguardo}
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm

\item
\subsubsection{Controllore RAID}

\item
\subsubsection{Livelli RAID}
La caratteristica fondamentale che identifica una configurazione RAID \`{e} l'array, che rappresenta il tipo di collegamento logico che c'\`{e} tra i vari dischi.
Con tale criterio viene determinato il livello RAID, ovvero la configurazione della tipologia di RAID  e stabilito il numero minimo di hard disk che sono necessari per attivarlo. A seconda del livello RAID sono implementate diverse caratteristiche operative per ottenere maggiori prestazioni o una maggiore sicurezza dei propri dati oppure entrambe le condizioni.\\
Si distinguono sei livelli, da 0 a 5.
Questo sistema numerato consente di differenziare le versioni e di scegliere come diffondere i dati attraverso l'array. Il numero di livelli \`{e} da allora ampliato ed \`{e} stato suddiviso in tre categorie: livelli RAID standard, nidificati e non standard.\cite{etichetta9}

\paragraph{Livelli RAID Standard}
\begin{itemize}
\begin{figure}[htbp]
\item 
\textbf{RAID \verb"O"}: livello privo di ridondanza. Si occupa di unire due o pi\`{u} dischi, all'interno dei quali i dati vengono suddivisi equamente (tramite striping o sezionamento), in modo da bilanciare anche il carico di operazioni di lettura e scrittura che li riguardano. In pratica, il livello zero consente di realizzare un disco virtuale di grandi dimensioni, pi\`{u} efficiente, ma la rottura di uno dei dischi porta alla perdita di tutti i dati. RAID-0 \`{e} noto anche con il nome di "block striping".\textbf{bibliografia commentata}\\
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm

\centering
\includegraphics[scale=0.40]{img/raid00.png}\\
\caption{Sezionamento senza ridondanza - Questa configurazione ha sezionamento, ma nessuna ridondanza dei dati. Offre le migliori prestazioni, ma nessuna tolleranza agli errori.\label{figura1.3}\cite{etichetta9}}
\end{figure}

\begin{figure}[htbp]
\item 
\textbf{RAID \verb"1"}: livello che si occupa di unire assieme due o pi\`{u} dischi (generalmente solo due) che si trovano a riprodurre fedelmente gli stessi dati. Questa configurazione mantiene quindi almeno una copia esatta di tutti i dati, detta "mirror". In questo caso, la rottura di un disco non pregiudica l'utilizzo dei dati che sono disponibili nel disco o nei dischi rimanenti.\\textbf{bibliografia commentata} Pi\`{u} precisamente, l'affidabilit\`{a} aumenta linearmente al numero di dischi presenti: un sistema con N dischi \`{e} in grado di resistere alla rottura di N-1 componenti.\\ La lettura delle prestazioni \`{e} migliorata poich\'{e} entrambi i dischi possono essere letti contemporaneamente. La scrittura delle prestazioni \`{e} la stessa di quella per il singolo disco.\cite{etichetta9} \\RAID-1 \`{e} conosciuto anche come "disk mirroring".\\
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm

%DA WIKIPEDIA
%A livello prestazionale, il sistema RAID 1 aumenta tipicamente i risultati per le operazioni di lettura, perché molte implementazioni sono in grado di effettuare diverse operazioni in parallelo: mentre la lettura di un blocco è ancora in corso su un disco, cioè, possono effettuarne un'altra su un disco diverso. In ogni caso, la velocità di lettura raggiunge quella del disco più veloce in presenza di dispositivi di memorizzazione con prestazioni diverse: una singola operazione di lettura è richiesta inizialmente e contemporaneamente su tutti i dischi, ma si conclude nel momento della prima risposta ricevuta. Viceversa, la velocità di scrittura scende a quella del disco più lento, perché questo tipo di azione richiede il compimento della replica della stessa operazione su ogni disco dell'insieme.
\centering
\includegraphics[scale=0.40]{img/raid11.png}\\
\caption{Replicazione - Questa configurazione \`{e} costituita da almeno due unit\`{a} che duplicano la memorizzazione dei dati. Non c'\`{e} sezionamento.\label{figura1.4} \cite{etichetta9}}
\end{figure}

\begin{figure}[htbp]
\item
\textbf{RAID \verb"2"}: livello che divide i dati al livello di bit (invece che di blocco) e usa un codice di Hamming per la correzione d'errore che permette di correggere errori su singoli bit e di rilevare errori doppi. Questi dischi sono sincronizzati dal controllore, in modo tale che la testina di ciascun disco sia nella stessa posizione in ogni disco. Questa configurazione si rivela molto efficiente in ambienti in cui si verificano numerosi errori di lettura o scrittura, ma in ambienti pi\`{u} prestanti, data l'elevata affidabilit\`{a} dei dischi, il RAID 2 non viene utilizzato. Oggi il RAID 2 viene infatti considerato obsoleto.\cite{etichetta10}\\

\centering
\includegraphics[scale=0.50]{img/raid22.png}\\
\caption{Sezionamento a livello di bit - Questa configurazione ha alcuni dischi che memorizzano le informazioni di errore di verifica e correzione (ECC).\label{figura1.6} \cite{etichetta9}}
\end{figure}

\begin{figure}[htbp]
\item
\textbf{RAID \verb"3"}: livello che si occupa di unire assieme almeno tre o pi\`{u} dischi, all'interno dei quali i dati vengono suddivisi equamente, in modo da bilanciare anche il carico di operazioni di lettura e scrittura che li riguardano. Dedicano uno di questi dischi al contenimento di un sistema di codici di controllo, che permettono di ricostruire i dati nel caso in cui uno degli altri dischi si rompa. Le informazioni ECC vengono utilizzate per rilevare gli errori. Il recupero dei dati viene effettuato calcolando l'esclusiva \verb"OR" (\verb"XOR") delle informazioni registrate sulle altre unit\`{a}.\cite{etichetta9} %Poiché un'operazione di I / O indirizza contemporaneamente tutte le unità, RAID 3 non può sovrapporre I / O. Per questo motivo, RAID 3 è la soluzione ideale per i sistemi a singolo utente con applicazioni di registrazione a lungo termine.
In pratica, il livello tre crea una forma di ridondanza, ma meno affidabile del livello uno.\\

%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm
\centering
\includegraphics[scale=0.40]{img/raid33.png}\\
\caption{Sezionamento a livello di byte con disco di parit\`{a} - Questa configurazione utilizza la rigatura e dedica un'unit\`{a} a memorizzare informazioni di parit\`{a}.\label{figura1.7} \cite{etichetta9}}
\end{figure}

\begin{figure}[htbp]
\item
\textbf{RAID \verb"4"}: livello simile al livello tre, con la differenza che i dati vengono distribuiti in modo pi\`{u} efficiente tra i dischi, ma rimane compito di un disco separato il sistema di codici di controllo che permette la ricostruzione dei dati, chiamati "blocchi di parit\`{a}".\\
Questo livello utilizza grandi sezionamenti, il che significa che \`{e} possibile leggere i record da un'unica unit\`{a}. Ci\`{o} consente di utilizzare I/O sovrapposti per operazioni di lettura. Poich\'{e} tutte le operazioni di scrittura devono aggiornare l'unit\`{a} di parit\`{a}, non \`{e} possibile sovrapporre I/O. RAID 4 non offre alcun vantaggio rispetto a RAID 5.\cite{etichetta9}\\
%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm
\centering
\includegraphics[scale=0.40]{img/raid44.png}\\
\caption{Sezionamento a livello di blocco con disco di parit\`{a}\label{figura1.8} \cite{etichetta9}}
\end{figure}

\begin{figure}[htbp]
\item
\textbf{RAID \verb"5"}: livello basato su striping a livello di blocco con parit\`{a}. Le informazioni sulla parit\`{a} risiedono su ciascuna unit\`{a}, consentendo all'array di funzionare anche se un drive non riesce. L'architettura dell'array consente alle operazioni di lettura e scrittura di coprire pi\`{u} unit\`{a}. Ci\`{o} determina prestazioni migliori di quelle di un'unit\`{a} singola, ma non altrettanto elevata di quella di un array RAID 0.\\ RAID 5 richiede almeno tre dischi, ma \`{e} spesso consigliato utilizzare almeno cinque dischi per motivi di prestazioni.

Gli array RAID 5 sono generalmente considerati una scelta scadente per l'utilizzo su sistemi a scrittura intensiva a causa dell'impatto delle prestazioni associato alla scrittura di informazioni sulla parit\`{a}. Quando un disco non \`{e} riuscito, pu\`{o} richiedere molto tempo per ricostruire un array RAID 5. La prestazione \`{e} generalmente degradata durante il tempo di ricostruzione e l'array \`{e} vulnerabile ad un ulteriore errore del disco fino a quando la ricostruzione non \`{e} completa.\cite{etichetta9}\\
%livello equivalente al livello quattro, dove per\`{o} le informazioni che servono per la ricostruzione dei dati sono distribuite tra i dischi, senza essere cos\`{i} concentrate in uno soltanto. In questo modo si aumenta l'efficienza, in termini di tempi di accesso ai dati.%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm

\centering
\includegraphics[scale=0.40]{img/raid55.png}\\
\caption{Sezionamento a livello di blocco con parit\`{a} distribuita\label{figura1.9} \cite{etichetta9}}
\end{figure}

\begin{figure}[htbp]
\item
\textbf{RAID \verb"6"}: livello simile a RAID 5, ma include un secondo schema di parit\`{a} distribuito attraverso le unit\`{a} nell'array. L'utilizzo di una parit\`{a} aggiuntiva consente all'array di continuare a funzionare anche se due dischi non funzionano contemporaneamente. Tuttavia, questa protezione supplementare \`{e} pi\`{u} costosa. Le matrici RAID 6 hanno un costo superiore a gigabyte (GB) e spesso hanno prestazioni di scrittura pi\`{u} lente degli array RAID 5.\cite{etichetta9}\\

%http://www.webalice.it/climberjak/linux_informatica/gestione_dei_dischi_in_modo_ridondante.htm
\centering
\includegraphics[scale=0.40]{img/raid66.png}\\
\caption{Sezionamento a livello di blocco con doppia parit\`{a} distribuita\label{figura1.10} \cite{etichetta9}}
\end{figure}

\end{itemize}


\paragraph{Livelli RAID Nidificati Annidati}
I livelli Annidati sono dei tipi di livelli pi\`{u} complessi ottenuti dalla combinazione di alcuni livelli RAID Standard. Esempi classici sono le configurazioni RAID 0+1 o 10.

\paragraph{Livelli RAID Non-Standard}


%per proteggere i dati nel caso di un guasto di unit\`{a}.

\textbf{spiegazione cinci -audio-}
Nelle macchine non distribuite
per garantire la ridondanza dei dati si scrive su piu dischi, sincrono (i dati vengono scritti simultaneamente) - come raid mirroring
ci puo essere o un affarino (scheda) chiamato raid controller. Ha una memoria che puoi configurarlo.. puoi dirgli tra disco 1 e disco 2 imponi un raid 0. Quindi che succede? Da una macchina, cioe dal processore, tutte le volte che viene fatta una scrittura su disco, il raid controller la splitta e viene fatta in entrambi i dischi. quindi hai due dischi clonati (mirroring). Stessa cosa del REPLICA.

\item
\subsection{Codice di correzione errore (Erasure Coding)}
La codifica di cancellazione, noto come \emph{Erasure Coding} (EC) \`{e} un metodo di protezione dei dati. Quest'ultimi vengono suddivisi in frammenti, estesi e codificati con pezzi di dati ridondanti e memorizzati su un insieme di posizioni o supporti di memorizzazione diversi.\cite{etichetta11}

L'obiettivo della codifica di cancellazione \`{e} quello di consentire di ricostruire i dati che vengono danneggiati utilizzando le informazioni sui dati memorizzati altrove nell'array. I codici di cancellazione vengono spesso utilizzati anzich\'{e} RAID tradizionali a causa della loro capacit\`{a} di ridurre il tempo e le spese generali necessarie per ricostruire i dati. Lo svantaggio della codifica di cancellazione \`{e} che pu\`{o} essere pi\`{u} intenso della CPU e che pu\`{o} tradursi in una maggiore latenza.\cite{etichetta11}

La codifica di cancellazione \`{e} utile con la presenza di grandi quantit\`{a} di dati e tutte le applicazioni o sistemi che devono tollerare i guasti, come sistemi di array a dischi, griglie di dati, applicazioni di archiviazione distribuite, negozi di oggetti e archiviazione di archiviazione. Un caso comune di utilizzo corrente per la codifica di cancellazione \`{e} in un sistema object-based cloud storage\cite{etichetta11}.

\subsubsection{Come funziona?}
La codifica di cancellazione crea una funzione matematica per descrivere un insieme di numeri in modo che possano essere controllati per l'accuratezza e recuperati in caso di perdita. Destinato a interpolazione polinomiale o oversampling, questo \`{e} il concetto fondamentale dei metodi di codifica di cancellazione, implementati pi\`{u} frequentemente utilizzando i codici \textit{Reed-Solomon}\cite{etichetta11}. 

In termini matematici, la protezione offerta dalla codifica di cancellazione pu\`{o} essere rappresentata in forma semplice dalla seguente equazione:  
\begin{verbatim}
                       		n = k + m
\end{verbatim}
dove:
\begin{itemize}
\item 
la variabile \verb"k" \`{e} la quantit\`{a} originale di dati o simboli. 
\item
la variabile \verb"m" indica i simboli aggiuntivi o ridondanti che vengono aggiunti per fornire protezione dai guasti. 
\item
la variabile \verb"n" \`{e} il numero totale di simboli creati dopo il processo di codifica di cancellazione\cite{etichetta11}.
\item
la variabile \verb"r", definita nel seguente modo: 
                       		\verb"r = "{k \over n}
\`{e} chiamata la velocit\`{a} di codice.\textbf{preso wiki}
\end{itemize}

Ad esempio, in una configurazione 10 di 16, o EC 10/16, sei simboli supplementari (\verb"m") saranno aggiunti ai 10 simboli di base (\verb"k"). I 16 frammenti di dati (\verb"n") saranno diffusi su 16 unit\`{a}, nodi o posizioni geografiche. Il file originale potrebbe essere ricostruito da 10 frammenti verificati.\cite{etichetta11}

I codici di cancellazione, noti anche come codici di correzione degli errori di avanzamento (FEC), sono stati sviluppati pi\`{u} di 50 anni fa. Da quel momento sono emersi diversi tipi. In uno dei tipi pi\`{u} comuni, Reed-Solomon, i dati possono essere ricostruiti utilizzando qualsiasi combinazione di simboli \verb"k" o pezzi di dati, anche se i simboli \verb"m" sono persi o non sono disponibili. Ad esempio, in EC 10/16, sei unit\`{a}, nodi o posizioni geografiche potrebbero essere persi o non disponibili e il file originale sar\`{a} ancora recuperabile.\cite{etichetta11}
 
\item
\section{Hardware utilizzato per gli esperimenti}
\textbf{Inserire foto hardware con descrizione}
\item
\section{Software utilizzato per gli esperimenti}
\item
\subsection{PosgreSQL}

\textbf{(spiegazione cinci -audio-)}
Uno dei punti di forza che ha reso famoso e versatile Posgres è che è un DBMS (Database Management System è un sistema software progettato per consentire la creazione e manipolazione efficiente di database (ovvero di collezioni di dati strutturati) ) (scritto in C). Ha dei rametti dove te riesci ad agganciarci dei software fatti ad OC. te ti agganci a un sistema di segnalistica interna e lui quindi tramite messaggi di scambio interno ti permette di lavorare (ti dice "ho fatto l'inserimento di questa tabella(INSERT), ti scatta il segnale, e te riesci a intercettare e quindi fare delle operazioni)

Pg Logical è un estensione di Posgres. Lui capisce quando fa inserimenti e riesce a duplicare soltando parti di database. Mentre replica di posgres per adesso ti replicherebbe tutto il DB. Invece noi si fa con solo tabelle (R) o quanti record di tabelle (per id maggiori di x) adirittura si vogliono replicare o colonne di tabelle \\


Con il termine PostgreSQL viene denominato un particolare ORDBMS, acronimo di Object-Relational DataBase Management System, cioè un software relazionale e ad oggetti per la gestione di basi di dati.
PostgreSQL è Open Source, quindi il suo codice sorgente è disponibile pubblicamente ed "aperto" ai contributi degli sviluppatori che volontariamente intendono partecipare alla sua implementazione.

In PostgreSQL, ma il discorso può essere allargato a tutti i gestori di database relazionali, i dati vengono rappresentati attraverso delle tabelle e le tabelle sono gestite utilizzando un linguaggio di alto livello chiamato SQL, acronimo di Structured Query Language.
Nel caso specifico, l'ORDBMS avrà il compito di gestire le operazioni di archiviazione e di salvaguardia dell'integrità dei dati allocati.

L'SQL è quindi un linguaggio a disposizione dell'utente da impiegare per "interfacciarsi" ai gestori di database; esso ha la caratteristica di agire in modo "trasparente", infatti le operazioni svolte a carico dei dati saranno portate avanti senza bisogno che l'utilizzatore sappia in che modo essi vengono trattati.\\
\textbf{(spiegazione cinci -audio-}\\
\textbf{(http://www.slony.info/images/Slony-I-concept.pdf}\\
Replicating schema changes is an often discussed problem and only ver y
fe w database systems provide the necessary hooks to implement it. PostgreSQL
does not provide the ability to define triggers called on schema changes, so a
transparent way to replicate schema changes is not possible without substantial
work in the core PostgreSQL system.
Moreover, ver y often database schema chages are not single, isolated DDL
statements that can occur at any time within a running system. Instead they tend
to be groups of DDL and DML statements that modify multiple database objects
and do mass data manipulation like updating a new column to its initial value.
The Slony-I replication system will have a mechanism to execute SQL
scr ipts in a controlled fashion as part of the replication process.

\item
\subsection{PG Logical}
L'estensione pglogical fornisce la replica logica di streaming per PostgreSQL, utilizzando un modulo di pubblicazione / sottoscrizione. Si basa sulla tecnologia sviluppata come parte del Progetto BDR.


PG Logical \`e un sistema logico di replica implementato come estensione di PostgreSQL. Completamente integrato, non richiede alcun triggers o programmi esterni. Questa alternativa alla replica fisica \`e un metodo altamente efficiente per replicare i dati utilizzando un modello di publish/subscribe per la replica selettiva.

I vantaggi offerti da Pg Logical sono i seguenti:
\begin{itemize}
\item
Replica sincrona
\item
Replica ritardata
\item
Risoluzione dei conflitti configurabili
\item
Capacit\`{a} di convertire lo standby fisico in una replica logica
\item
Pu\`{o} pubblicare i dati da PostgreSQL a un abbonato Postgres-XL
\item
Le sequenze possono essere replicate
\item
Nessun trigger significa ridurre il carico di scrittura sul Provider
\item
Nessuna re-esecuzione di SQL significa overhead e latenza ridotti per il Sottoscrittore
\item
Il sottoscrittore non \`{e} in ripristino di riposo caldo, in modo da poter utilizzare tavoli temp, non sbloccati o normali
\item
Non \`{e} necessario annullare le query per consentire alla replica di continuare la riproduzione
\item
Il sottoscrittore (Subscriber) pu\`{o} avere diversi utenti e protezione, indici diversi, impostazioni di parametri diversi
\item
Replica solo un database o un sottoinsieme di tabelle, noto come set di replica (Replication Sets)
\item
Replicare in versioni o architetture di PostgreSQL, consentendo aggiornamenti a bassa o zero-downtime
\item
Pi\`{u} server a monte in un singolo subscriber per l'accumulo di cambiamenti
\end{itemize}

Come funziona pglogical?
Pglogical utilizza le funzioni di Decodifica Logica aggiunte da 2ndQuadrant (e disponibili da PostgreSQL 9.4). Pglogical funziona ancora più veloce con PostgreSQL 9.5 e successive, con bassi overhead su entrambi i provider e abbonati.

Pglogical si basa molto sulle caratteristiche introdotte nell'ambito dello sviluppo BDR, tra cui:

Decodifica logica
Slot di replica
Lavoratori di sfondo statico
Origini di replica
Impegnano timestamp
Messaggi WAL logici
Replica pglogical Bi-Directional Replication (BDR)?
No. pglogical non fornisce funzionalità complete di replica multi-master e un supporto di modifica dello schema coerente, come fa la BDR. Pglogical incorpora le funzionalità di BDR e le lezioni apprese da BDR per produrre una soluzione più semplice e più semplice da utilizzare per la replica unidirezionale, utilizzabile da più persone per una vasta gamma di casi di utilizzo. BDR è stato progettato innanzitutto per il multi-master della rete a n-way, e questo è stato difficile adattarsi bene alla replica mono-master a senso unico.

Lo sviluppo di BDR continuerà per quelli che richiedono piena capacità multi-master, riutilizzando gran parte del codice da pglogical.


Casi di uso:
I diagrammi che seguono descrivono i gestori di database delle funzioni che sono in grado di eseguire con PgLogical.
\begin{figure}[htbp]
\centering
Migrare e aggiornare PostgreSQL con tempi di inattivit\`a quasi a zero
\includegraphics[scale=0.70]{img/pglogical_1.png}\\
\caption{Migrazione e aggiornamenti PostgreSQL \label{figura1} \cite{etichetta3}}
Accumulare le modifiche provenienti da server di database scartati in un data warehouse
\includegraphics[scale=0.70]{img/pglogical_2.png}\\
\caption{Aggregazione \label{figura2} 
\cite{etichetta4}}
\end{figure}
\begin{figure}[htbp]
\centering
Copiare tutti o una selezione di tabelle di database ad altri nodi di un cluster
\includegraphics[scale=0.70]{img/pglogical_3.png}\\
\caption{A cascata e distribuzione dati \label{figura3} \cite{etichetta4}}
Le modifiche del database in tempo reale ad altri sistemi
\includegraphics[scale=0.70]{img/pglogical_4.png}\\
\caption{A cascata e distribuzione dati \label{figura4} \cite{etichetta4}}
\end{figure}

\texttt{DA METTERE? DIFFERENZA TRA PG LOGICAL E BDR}
Replica pglogical Bi-Directional Replication (BDR)?
No. pglogical non fornisce funzionalità complete di replica multi-master e un supporto di modifica dello schema coerente, come fa la BDR. Pglogical incorpora le funzionalità di BDR e le lezioni apprese da BDR per produrre una soluzione più semplice e più semplice da utilizzare per la replica unidirezionale, utilizzabile da più persone per una vasta gamma di casi di utilizzo. BDR è stato progettato innanzitutto per il multi-master della rete a n-way, e questo è stato difficile adattarsi bene alla replica mono-master a senso unico.
%\end{document}
